package FkHzOD_B_latest;

import java.util.Arrays;
import java.util.Scanner;

/**
 * B|9|食堂供餐|二分法|100|
 * 某公司员工食堂以盒饭方式供餐。为将员工取餐排队时间降低为0，食堂的供餐速度必须要足够快。
 * 现在需要根据以往员工取餐的统计信息，计算出一个刚好能达成排队时间为0的最低供餐速度。
 * 即，食堂在每个单位时间内必须至少做出多少份盒饭才能满足要求。
 *
 * 输入描述:
 * 第1行为一个正整数N，表示食堂开餐时长。1 <= N <= 1000。
 * 第2行为一个正整数M，表示开餐前食堂已经准备好的盒饭份数。pi <= M <= 1000.
 * 第3行为N个正整数，用空格分隔，依次表示开餐时间内按时间顺序每个单位时间进入食堂取餐的人数Pi。1 <=i<= N，0<= Pi<=100.
 * 输出描述:
 * 1个整数，能满足题目要求的最低供餐速度(每个单位时间需要做出多少份盒饭)
 * 补充说明:
 * 每人只取一份盒饭。
 * 需要满足排队时间为0，必须保证取餐员工到达食堂时，食堂库存盒饭数量不少于本次来取餐的人数。
 * 第一个单位时间来取餐的员工只能取开餐前食堂准备好的盒饭。
 * 每个单位时间里制作的盒饭只能供应给后续单位时间来的取餐的员工。
 * 食堂在每个单位时间里制作的盒饭数量是相同的。
 *
 * 示例1 输入:
 * 3 -> N
 * 14 -> M
 * 10 4 5
 * 输出: 3
 * 说明:
 * 本样例中，总共有3批员工就餐，每批人数分别为10、4、5.
 * 开餐前食堂库存14份。
 * 食堂每个单位时间至少要做出3份餐饭才能达成排队时间为0的目标。具体情况如下:
 * 第一个单位时间来的10位员工直接从库存取餐。
 * 取餐后库存剩余4份盒饭，加上第一个单位时间做出的3份，库存有7份。第一个单位时间来的4员工从库存的7份中取4份。
 * 取餐后库存剩余3份盒饭，加上第二个单位时间做出的3份，库存有6份第二个单位时间来的员工从库存的6份中取5份，库存足够。
 *
 * 思路：
 * 二分法，target是最小速度，最小出餐速度left = 0，最大出餐速度right = 总人数 - 已准备好的盒饭
 * 从最小到最大的速度间，不断二分找 刚好分给最后一组人时不为负的速度
 */
public class B9食堂供餐 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        int M = in.nextInt();
        in.nextLine();
        int[] nums = Arrays.stream(in.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();

        int l = 0; //最小速度
        int r = Arrays.stream(nums).sum() - M; //最大速度
        int total = M; // 总库存
        while (l < r) {
            int speed = l + (r - l) / 2;
            for (int i = 0; i < N; i++) {
                total = total - nums[i];
                if (total < 0) { // 慢了就要加速
                    l = speed + 1;
                    break;
                }
                total += speed; //每轮新产出
            }
            r = speed;
        }
        System.out.println("speed: " + l);

    }
}
